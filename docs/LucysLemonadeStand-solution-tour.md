# Lucy's Lemonade Stand - Solution Tour

I came up with this sample project with the goal of having an overall simple to understand case study that's just complex enough to showcase a variety of testing concepts, methodologies, and libraries.

The projects in the `\src` folder represent a simple lemonade stand API.
It handles only the sort of actions that you'd expect a little girl to be able to handle and learn business from:

* Manage a pitcher of lemonade of arbitrarily large volume
* Be able to tell people the price of lemonade ($0.50 per cup) (and also know how much it would cost to refill the pitcher with 8 cups)
* Keep track of money
* Handle orders for cups of lemonade including validating that the cash given to her is adequate.
  She can also return change as needed. 
  Money is not considered in denominations in this version since I felt it would complicate things too much.
  Imagine everything is in weightless pennies.
* Show a history of orders
* Ask mom for a refill of the pitcher of lemonade.

These are all the endpoints in Lucy's API.

## Some technical details

* The main project uses **Clean Architecture**, or tries to get as close as possible to that goal with the limitations brought on by using stored procedures and Dapper instead of Entity Framework.
* The main project is built on the FastEndpoints framework, which is built on top of minimal APIs.
  Though opinionated, this framework includes a huge amount of functionality in a very clean way.
* The solution uses a MS SQL database and connects to an external API (Mom).
  These are the core of my integration tests.

## \src Projects

* **LucysLemonadeStand** - This is the main startup project that contains the API definitions. 
* **LucysLemonadeStand.SharedKernel** - This contains super-generic code that could potentially be made as NuGet packages.
  It contains repository interfaces, a DateTimeProvider, and classes for Pagination.
* **LucysLemonadeStand.Core** - This is where common models, interfaces, and infrastructure-agnostic business logic classes are defined.
* **LucysLemonadeStand.Infrastructure** - This is where the interfaces from the Core project are implemented if they have a connection to infrastructure and therefore cannot be written in an agnostic way (at least with the limitations of the selected technologies).
* **LucysLemonadeStand.DB** - This is the database project, where tables, stored procedures, and starting values are defined.
* **Mom.Client** - This is a project that holds code that's invisible, auto-generated by NSwag code-gen, based off the Mom API, which has only one endpoint to create pitcher refills.

## \External Project
* **Mom** - This is a super-simple API with one endpoint that Lucy can call when she needs a refill for her pitcher of lemonade.
  Mom takes about $3.20 per pitcher of 8 cups ($0.40 each), although if Lucy gives her more, Mom will not return any change in order to teach Lucy to be precise with her math.

  Note that Mom gets tired easily from all the lemon squeezing and is prone to occasionally return a code 429 Too Many Requests HTTP response.
  The chance of her doing this goes up on each refill until she has a break.

## \tests Projects

The project names are named with the pattern {project that's being tested}.\{type of tests}.

* **LucysLemonadeStand.Core.UnitTests** - Since the Core project holds a lot of business logic and is independent of infrastructure, it only gets unit tests and is perfect to show that concept.
* **LucysLemonadeStand.Infrastructure.UnitTests** - The infrastructure project connects to external sources. 
  To have unit testing of the things in that library, it's critical to replace connections to external systems with mocks.
* **LucysLemonadeStand.Infrastructure.IntegrationTests** - Unit tests can only get us so far when it comes to making sure the calls to external programs will work correctly.
  Integration tests will connect to real systems that are stand-in replacements for the real thing so all the connection protocols are tested.
* **LucysLemonadeStand.IntegrationTests** - We can't forget to make sure that the API itself has the ability to take in requests as we expect them to be sent and handle them.
  This library can almost be an end-to-end test, except that APIs are usually just one part of a larger system so e2e tests would involve more than just this.

## Run it yourself

[Here are instructions for how to set up the project's environment to run it locally.](project-setup.md)